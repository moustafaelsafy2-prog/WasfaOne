// netlify/functions/aiDietAssistant.js
// Fully-AI WhatsApp-like diet assistant (Arabic), same model pool & gates as generateRecipe.
// - No canned replies. All messages are generated by the model.
// - Uses the same subscription gate & headers (x-auth-token, x-session-nonce).
// - Compatible with app.html widget (POST { messages:[{role,content}], lang } -> { ok, reply, model }).

const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "";
const BASE = "https://generativelanguage.googleapis.com/v1beta/models";

/* Same model pool as generateRecipe */
const MODEL_POOL = [
  "gemini-1.5-pro-latest",
  "gemini-1.5-pro",
  "gemini-1.5-pro-001",
  "gemini-pro",
  "gemini-1.0-pro",
  "gemini-2.0-flash",
  "gemini-2.0-flash-exp",
  "gemini-1.5-flash",
  "gemini-1.5-flash-001",
  "gemini-1.5-flash-latest"
];

/* ---------------- GitHub helpers for subscription gate ---------------- */
const OWNER = process.env.GITHUB_REPO_OWNER;
const REPO  = process.env.GITHUB_REPO_NAME;
const REF   = process.env.GITHUB_REF || "main";
const GH_TOKEN = process.env.GITHUB_TOKEN;
const GH_API = "https://api.github.com";
const USERS_PATH = "data/users.json";

async function ghGetJson(path){
  const r = await fetch(`${GH_API}/repos/${OWNER}/${REPO}/contents/${path}?ref=${REF}`, {
    headers: { Authorization: `token ${GH_TOKEN}`, "User-Agent":"WasfaOne" }
  });
  if(!r.ok) throw new Error(`GitHub GET ${path} ${r.status}`);
  const data = await r.json();
  const content = Buffer.from(data.content || "", "base64").toString("utf-8");
  return { json: JSON.parse(content), sha: data.sha };
}

async function ghPutJson(path, json, sha, message){
  const content = Buffer.from(JSON.stringify(json, null, 2), "utf-8").toString("base64");
  const r = await fetch(`${GH_API}/repos/${OWNER}/${REPO}/contents/${path}`, {
    method:"PUT",
    headers:{ Authorization:`token ${GH_TOKEN}`, "User-Agent":"WasfaOne", "Content-Type":"application/json" },
    body: JSON.stringify({ message, content, sha, branch: REF })
  });
  if(!r.ok) throw new Error(`GitHub PUT ${path} ${r.status}`);
  return r.json();
}

function todayDubai(){
  const now = new Date();
  return now.toLocaleDateString("en-CA", { timeZone:"Asia/Dubai", year:"numeric", month:"2-digit", day:"2-digit" });
}
function withinWindow(start, end){
  const d = todayDubai();
  if(start && d < start) return false;
  if(end && d > end) return false;
  return true;
}

/* ---------------- HTTP helpers ---------------- */
const headers = {
  "Content-Type": "application/json; charset=utf-8",
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "Content-Type, X-Auth-Token, X-Session-Nonce",
  "Access-Control-Allow-Methods": "POST, OPTIONS"
};
const jsonRes = (code, obj) => ({ statusCode: code, headers, body: JSON.stringify(obj) });
const bad = (code, error, extra = {}) => jsonRes(code, { ok: false, error, ...extra });
const ok  = (payload) => jsonRes(200, { ok: true, ...payload });

/* ---------------- Subscription gate (same as generateRecipe) ---------------- */
async function ensureActiveSubscription(event) {
  const token = event.headers["x-auth-token"] || event.headers["X-Auth-Token"];
  const nonce = event.headers["x-session-nonce"] || event.headers["X-Session-Nonce"];
  if (!token || !nonce) return { ok:false, code:401, msg:"unauthorized" };

  const { json: users, sha } = await ghGetJson(USERS_PATH);
  const idx = (users||[]).findIndex(u => (u.auth_token||"") === token);
  if (idx === -1) return { ok:false, code:401, msg:"unauthorized" };

  const user = users[idx];
  if ((user.session_nonce||"") !== nonce) return { ok:false, code:401, msg:"bad_session" };

  const today = todayDubai();
  if (user.end_date && today > user.end_date) {
    user.status = "suspended";
    user.lock_reason = "expired";
    users[idx] = user;
    await ghPutJson(USERS_PATH, users, sha, `assistant: auto-suspend expired ${user.email}`);
    return { ok:false, code:403, msg:"subscription_expired" };
  }

  if ((String(user.status||"").toLowerCase() !== "active") || !withinWindow(user.start_date, user.end_date)) {
    return { ok:false, code:403, msg:"inactive_or_out_of_window" };
  }

  return { ok:true, user };
}

/* ---------------- Prompting ---------------- */
function systemPrompt(lang="ar"){
  // WhatsApp-like tone, Arabic formal-friendly, concise turns, clear bullets when needed.
  return `
أنت مساعد تغذية عربي يعمل بنمط محادثة شبيه بالواتساب. هدفك تحديد أفضل نظام غذائي للمستخدم ثم إرشاده خطوة بخطوة.
قواعد إلزامية:
- اللغة العربية الفصحى المبسطة، جُمل قصيرة واضحة، دون وجوه تعبيرية أو زخارف.
- لا تعتمد على أي ردود جاهزة؛ كوّن الرد بالكامل بناءً على سياق المحادثة.
- اسأل على مراحل، بحد أقصى سؤالين في الرسالة الواحدة، حتى تجمع المعطيات الأساسية:
  (الهدف، الجنس/العمر، الطول، الوزن، مستوى النشاط، الأمراض/الأدوية، تفضيلات الطعام والحساسيات، الميزانية الزمنية للطبخ).
- عند نقص البيانات، لا تفترض؛ اسأل بديلًا.
- قدّم نصائح عملية قابلة للتنفيذ (وجبات، تقسيم سعرات، ماكروز تقريبية، بدائل واقعية).
- التزم بالحساسيّات والأنظمة التي يذكرها المستخدم (كيتو/متوسطي/مخصص… إلخ).
- عند ذكر نظام مخصّص، ذكّر أن السعرات تحسب وفق 4/4/9، ويمكن مواءمة الوجبات لتحقيق الماكروز.
- تجنّب النصائح الطبية عالية الخطورة؛ إن وُجدت حالة خاصة (سُكري، كِلى، كبد، حمل)، نبّه بلطف بمراجعة مختص.

نسّق الردود كرسائل قصيرة، ويمكن استخدام نقاط موجزة عند الحاجة.
`.trim();
}

/* Convert client messages (role, content) to Gemini contents */
function toGeminiContents(messages){
  const parts = [];
  const contents = [];
  (messages||[]).forEach(m=>{
    const role = m.role === "assistant" ? "model" : "user";
    contents.push({ role, parts: [{ text: String(m.content||"") }]});
  });
  return contents;
}

/* ---------------- Call model ---------------- */
async function callModel(model, contents, timeoutMs = 20000){
  const url = `${BASE}/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(GEMINI_API_KEY)}`;
  const body = {
    systemInstruction: { role:"system", parts:[{ text: systemPrompt("ar") }] },
    contents,
    generationConfig: { temperature: 0.5, topP: 0.9, maxOutputTokens: 700 },
    safetySettings: []
  };

  const abort = new AbortController();
  const t = setTimeout(()=>abort.abort(), Math.max(1000, Math.min(22000, timeoutMs)));

  let resp, data;
  try{
    resp = await fetch(url, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body), signal: abort.signal });
    const txt = await resp.text();
    try{ data = JSON.parse(txt); }catch{ data = null; }
    if(!resp.ok){
      const msg = data?.error?.message || `HTTP_${resp.status}`;
      return { ok:false, error: msg };
    }
    const reply =
      data?.candidates?.[0]?.content?.parts?.map(p=>p?.text||"").join("") ||
      data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
    if(!reply || !reply.trim()) return { ok:false, error:"empty_reply" };
    return { ok:true, reply: reply.trim() };
  }catch(e){
    return { ok:false, error: String(e && e.message || e) };
  }finally{
    clearTimeout(t);
  }
}

/* ---------------- Handler ---------------- */
exports.handler = async (event) => {
  if (event.httpMethod === "OPTIONS") return jsonRes(204, {});
  if (event.httpMethod !== "POST") return bad(405, "Method Not Allowed");
  if (!GEMINI_API_KEY) return bad(500, "GEMINI_API_KEY is missing on the server");

  // Subscription enforcement
  try{
    const gate = await ensureActiveSubscription(event);
    if(!gate.ok) return bad(gate.code, gate.msg);
  }catch(_){
    return bad(500, "subscription_gate_error");
  }

  let body = {};
  try{ body = JSON.parse(event.body || "{}"); }
  catch{ return bad(400, "invalid_json_body"); }

  const messages = Array.isArray(body.messages) ? body.messages : [];
  const lang = body.lang || "ar";

  // If no history, ask the model to greet and ask first two key questions (goal + weight/height)
  const contents = toGeminiContents(messages.length ? messages : [
    { role:"user", content:"ابدأ التحية وقدّم نفسك كمساعد تغذية، واسألني أول سؤالين أساسيين لتحديد هدفي وبياناتي." }
  ]);

  const errors = {};
  for (const model of MODEL_POOL){
    const r = await callModel(model, contents);
    if (r.ok) return ok({ reply: r.reply, model });
    errors[model] = r.error;
  }
  return bad(502, "All models failed for your key/region on v1beta", { errors, tried: MODEL_POOL });
};
